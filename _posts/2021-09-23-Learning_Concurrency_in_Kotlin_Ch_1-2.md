---
layout: post
title: "<코틀린 동시성 프로그래밍> Chap 1-2 동시성"
author: "Lin"
tags: Coroutine

---

> 본 게시물은 [코틀린 동시성 프로그래밍 예제로 배우는 코틀린 동시성](https://book.naver.com/bookdb/book_detail.nhn?bid=16364412) 책을 기반으로 작성되었습니다. 
>
> 보다 더 자세한 내용을 책을 참고해주세요.

<br>

# 동시성

동시성 코드는 결정론적인 결과를 갖지만 실행 순서에는 약간의 가변성을 허용하는 코드

<br>

## 순차적인 코드 vs 동시성 코드

#### 순차적인 코드 

- 장점: 정확한 실행 순서를 쉽게 알 수 있다.
- 단점
  - 동시성 코드에 비해 성능 저하
  - 코드가 실행되는 하드웨어 활용도 낮음

<br>

## 동시성 vs 병렬성

- 동시성: 같은 프로세스 안에서 서로 다른 명령 집합의 타임라인이 겹칠 때 발생
  - 최소 2개 이상의 실행 스레드 존재 
  - 단일 코어가 서로 다른 스레드의 인스트럭션을 교차 배치 
- 병렬성: 두 스레드가 정확히 같은 시점에 실행될 때만 발생 
  - 최소 두 개 이상의 코어와 두 개 이상의 스레드 존재 
  - 각 코어가 동시에 스레드의 인스트럭션 발생 

`병렬은 동시성을 의미하지만, 동시성은 병렬성 없이도 발생 가능`

![이미지](https://t1.daumcdn.net/cfile/tistory/99AD02405FBBB94910)

<br>

## CPU 바운드와 I/O 바운드 

### CPU 바운드

CPU만 완료하면 되는 작업을 중심으로 구현되는 알고리즘

#### 동시성과 병렬성

다중 코어에서 병렬성을 활용하면 성능 향상

단일 코어에서 동시성을 구현하면 성능 저하  (컨텍스트 스위칭 발생)

<br>

### I/O 바운드

입출력 장치에 의존하는 알고리즘

#### 동시성과 병렬성

동시성 알고리즘은 순차적인 알고리즘보다 동시성 구현에서 항상 더 좋은 성능

<br>

## 동시성이 어려운 이유

### 레이스 컨디션 

동시성 코드가 항상 특정한 순서로 실행될 것이라고 가정하고 오해할 때 생기는 문제 

### 원자성 위반

원자성은 객체의 상태가 동시에 수정될 수 있을 때 필요하며 그 상태의 수정이 겹치지 않도록 보장해야 한다.

수정이 겹칠 수 있다는 것은 데이터 손실이 발생할 수 있다는 것이다.

### 교착 상태

순환적 의존성으로 인해 다음 처리를 하지 못하는 상황

레이스 컨디션과 자주 같이 발생 

### 라이브 락

앱의 상태가 지속적으로 변하지만 앱이 정상 실행으로 돌아오지 못하게 하는 방향으로 상태가 변경 

교착 상태를 복구하도록 설계된 알고리즘에서 발생하는 경우가 많다.

<br>
<br>

# 코틀린의 동시성

 동시성 프로그램에서 코틀린의 가장 차별화된 특징

<br>

### 넌 블로킹 

중단 가능한 연산 기능 제공: 스레드의 실행을 블로킹하지 않으면서 실행을 잠시 중단한다.

코틀린은 채널(channels), 액터(actors), 상호 배제(mutual exclusions)와 같은 기본형을 제공해 효과적인 통신 및 동기화 메커니즘 제공

<br>

### 명시적인 선언

동시성은 연산이 동시에 실행돼야 하는 시점을 명시적으로 만드는 것이 중요

-> `일시 중단 가능한 연산(Suspendable computations)`는 기본적으로 순차적으로 실행 <br>
연산은 일시 중단될 때 스레드를 블로킹하지 않기 때문에 직접적인 단점은 X

<br> 

### 가독성

코틀린의 접근법은 관용구적인 동시성 코드를 허용 -> 읽기 쉽다

> suspend 메소드: 백그라운드 스레드에서 실행될 메소드를 호출하고 정보를 처리하기 전에 완료를 기다린다.
>
> 팁: 비동기 함수를 작성하는 것보다 suspend 함수를 작서앟는 게 좋다. 함수의 호출자에게 더 많은 유연성을 제공한다. 

<br> 

### 기본형 활용

코틀린은 동시성 코드를 쉽게 구현할 수 있는 고급 함수와 기본형을 제공

- 스레드는 스레드 이름을 파라미터로 하는 `newSingleThreadContext()`를 호출하면 생성 
- 스레드 풀은 크기와 이름을 파라미터로 하는 `newFixedThreadPoolContext()`를 호출하면 생성
- CommonPool은 CPU 바운드 작업에 최적인 스레드 풀 (최대 크기는 시스템 코어에서 1을 뺀 값)
- 코루틴을 다른 스레드로 이동시키는 역할은 런타임이 담당
- 채널, 뮤텍스 및 스레드 한정과 같은 코루틴의 통신과 동기화를 위해 필요한 많은 기본형과 기술이 제공 

<br> 

### 유연성

간단하면서도 유연하게 동시성을 사용하게 해주는 기본형 많이 제공

- 채널: 코루틴 간에 데이터를 안전하게 보내고 받는 데 사용할 수 있는 파이프
- 작업자 풀: 많은 스레드에서 연삽 집합의 처리를 나눌 수 있는 코루틴의 풀
- 액터: 채널과 코루틴을 사용하는 상태로 감싼 래퍼로 여러 스레드에서 상태를 안전하게 수정하는 메커니즘 제공 
- 뮤텍스: 크리티컬 존 영역을 정의해 한 번에 하나의 스레듬나 실행할 수 있도록 하는 동기화 메커니즘 
- 스레드 한정: 코루틴의 실행을 제한해서 지정된 스레드에서만 실행하도록 하는 기능 
- 생성자(반복자 및 시퀀스): 필요에 따라 정보를 생성할 수 있고 새로운 정보가 필요하지 않을 때 일시 중단될 수 있는 데이터 소스 

<br> 

## 코틀린 동시성 관련 개념과 용어

### 일시 중단 연산

해당 스레드를 차단하지 않고 실행을 일시 중지할 수 있는 연산 

일시 중단 연산을 통해 스레드를 다시 시작해야 할 때까지 스레드를 다른 연산에서 사용 가능

<br> 

### 일시 중단 함수

함수 형식의 일시 중단 연산

`suspend` 제어자로 쉽게 식별 가능 

<br> 

### 람다 일시 중단

익명의 로컬 함수 

다른 일시 중단 함수를 호출함으로써 자신의 실행을 중단할 수 있다

<br> 

### 코루틴 디스패처 

코루틴을 시작하거나 재개할 스레드를 결정하기 위해 사용 

모든 코루틴 디스패처는 `CoroutineDispatcher` 인터페이스를 구현해야 한다

- DefaultDispatcher: 현재는 CommonPool과 동일
- CommonPool: 공유된 백그라운드 스레드 풀에서 코루틴을 실행하고 다시 시작 (기본 크기는 CPU 바운드 작업에 사용하기 적합)
- Unconfined: 현재 스레드에서 코루틴을 시작하지만 어떤 스레드에서 코루틴이 재개될 수 있다. 

<br> 디스패처와 함께 필요에 따라 풀 또는 스레드를 정의하는 데 사용할 수 있는 몇 가지 빌더가 있다.

- newSingleThreadContext(): 단일 스레드로 디스패처 생성
- newFixedThreadPoolContext(): 지정된 크기의 스레드 풀이 있는 디스패처 생성 

<br> 

### 코루틴 빌더

일시 중단 람다를 받아 그것을 실행시키는 코루틴을 생성하는 함수 

- async(): 결과가 예상되는 코루틴을 시작

  - 코루틴 내부의 모든 예외를 캡처해서 결과에 넣기 때문에 조심히 사용
  - 결과 또는 예외를 포함하는 `Deferred<T>` 반환

- launch(): 결과를 반환하지 않는 코루틴을 시작

  - 자체 혹은 자식 코루틴의 실행을 취소하기 위해 사용할 수 있는 `Job` 반환

- runBlocking(): 블로킹 코드를 일시 중지 가능한 코드로 연결하기 위해 사용 

  - 코루틴의 실행이 끝날 때까지 현재 스레드를 차단 

  



