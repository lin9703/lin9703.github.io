---
layout: post
title: "<안드로이드 프로그래밍> Ch.4 UI 상태 유지하기 (AAC ViewModel, SIS)"
author: "Lin"
tags: Android
---

> 본 게시물은 [실무에 바로 적용하는 안드로이드 프로그래밍](https://book.naver.com/bookdb/book_detail.nhn?bid=18123166) 책을 기반으로 작성되었습니다.

<br>

[실습 코드](https://github.com/lin9703/android-practice-code/tree/main/GeoQuiz)

# AAC ViewModel
안드로이드는 적절한 시점에 리소스를 제공하지만, 화면 회전과 같은 환경 변화에 따른 액티비티 소멸 및 재생성은 문제가 생길 수 있다.

-> AAC ViewModel에 UI 데이터를 저장해 앱의 UI 상태가 유실되는 결함 해결 

<br>
**AAC ViewModel** : 모델 데이터를 화면에 보여주는 기능 수행 

- 생명주기 인식하는 컴포넌트를 포함하고 생명주기 관련 API를 제공하는 androidx.lifecycle 패키지의 일부 
- 화면에서 필요한 모든 `데이터를 한곳에서 종합`하고 `데이터 형식화` 가능 
    - `데이터 형식화`: 프레젠테이션 로직 코드를 액티비티와 분리하여 액티비티 간결화 가능 <br>
        -> 액티비티는 화면에 나타나는 것을 처리하는 것만 집중하고 보여줄 데이터를 결정하는 내부 로직은 신경 쓰지 않아도 된다.

<br>

## ViewModel 생명주기 
장치의 구성 변경이 생겨도 계속 존재하다가 액티비티가 종료될 때만 소멸

ViewModel 인스턴스는 `액티비티의 생명주기와 연동`
- 액티비티 상태 변화와 무관하게 액티비티가 종료될 때까지 메모리에 남아있다가 액티비티가 종료되면 소멸 
- onCleared() 함수: ViewModel 인스턴스 소멸 전 호출 

<br>

## 액티비티와 ViewModel의 관계 

액티비티와 ViewModel은 `단방향 관계`이다.

액티비티는 ViewModel을 참조하지만, ViewModel은 액티비티를 참조하지 않는다.

ViewModel이 액티비티나 다른 뷰의 참조를 가지면 `메모리 유실`이 생길 수 있다. <br>
참조되는 개체를 가비지 컬렉터가 메모리에서 제거할 수 없어진다. (강한 참조) <br>
#### 문제점 
1. 액티비티 인스턴스가 메모리에서 제거되지 않아 이 인스턴스가 사용하는 `메모리 유실`
2. ViewModel 인스턴스가 현재 사용되지 않는 과거의 액티비티의 참조를 갖게 되어 ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 `IllegalStateException` 발생 

<br>
<br>
<hr>

# SIS (Saved Instance State)
각 앱은 `리눅스 프로세스`로 실행되며, 사용자가 다른 앱으로 이용하거나 안드로이드 운영체제가 메모리를 회수할 때 `안드로이드 프로세스는 안드로이드 운영체제에 의해 소멸`된다.
- 높은 우선순위: '실행 재개', '일시 중지'
    - 화면에 보이는 액티비티를 포함하는 프로세스는 리소스 회수가 되지 않는다.
- 낮은 우선순위: '중단'

<br>
안드로이드 운영체제가 앱의 프로세스를 소멸시킬 때 메모리에 있는 앱의 모든 액티비티와 ViewModel이 제거되지만, <br>
`액티비티나 ViewModel의 생명주기 콜백 함수`는 호출되지 않는다.

-> `SIS(Saved Instance State, 저장된 인스턴스 상태)`에 데이터를 저장해 UI 상태 보존 가능

1. SIS는 안드로이드 운영체제가 일시적으로 `액티비티 외부에 저장하는 데이터`
2. 액티비티의 슈퍼클래스에 기본 구현된 'onSaveInstanceState(Bundle)'는 `현재 액티비티의 모든 뷰가 자신들의 상태를 Bundle 객체 데이터로 저장` 
    - Bundle은 문자열 키와 값을 쌍으로 갖는 구조체 
3. 액티비티가 '중단' 상태가 되고 `종료 대상`이 되어 종료된다면 이미 'Activity.onSaveInstanceState(Bundle)' 호출
4. `Activity.onSaveInstanceState(Bundle)`을 override해 SIS 데이터 추가 가능
5. `onCreate(Bundle?)`은 Bundle 객체를 통해 액티비티의 뷰 계층 다시 생성

<br>

## SIS와 액티비티 레코드
onSaveInstanceState(Bundle)이 호출될 때 데이터가 저장된 Bundle 객체는 안드로이드 운영체제에 의해
액티비티의 `액티비티 레코드(Activity Record)`로 저장 

<br>

### 액티비티 보존 상태
> 액티비티 인스턴스는 존재하지 않지만, 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다. 

액티비티는 onDestroy()가 호출되지 않고 보존 상태가 될 수 있다.

따라서, onStop()과 onSaveInstanceState(Bundle)이 호출되는 것에 의존해서 코드 작성 
- 일반적으로 작고 일시적인 상태 데이터를 보존하기 위해 onSaveInstanceState(Bundle) override
- 지속해서 저장할 데이터는 onStop() override (이 함수가 실행된 후에는 언제든 액티비티가 소멸 가능하기 때문에)

<br>

### 액티비티 레코드 소멸
1. 액티비티가 종료되면 같이 소멸 
2. 장치가 다시 부팅될 때도 폐기 

<br>
<br>
<hr>

# ViewModel vs SIS

대부분의 앱은 데이터베이스, 인터넷으로부터 동적인 데이터를 가져온다. <br>
이런 작업은 비동기적이며 느릴 수 있고, 배터리나 리소스를 많이 사용한다. <br>
이런 작업을 생명주기와 결속해서 처리하면 오류가 발생할 수도 있다. 

-> ViewModel은 `동적 데이터`를 처리 할 때 유용하다
1. 장치 구성이 변경되어도 다운로드 작업 지속
2. 사용자가 액티비티를 끝내면 자동으로 클린업 

-> 그러나 프로세스가 종료되면 사용 불가 <br>
-> 이럴 때, SIS는 사용 가능하지만 제약 존재
- 직렬화되어 디스크에 저장되므로 크거나 복잡한 객체를 저장하는 것은 피해야 한다.


### 요약 
- SIS: UI 상태를 다시 생성하기 위한 소량의 정보를 저장할 때 사용
- ViewModel: 장치의 구성 변경이 생겨서 UI 넣는 데 필요한 많은 데이터에 빠르고 쉽게 접근하고자 메모리에 캐싱할 때 사용 

