---
layout: post
title: "JAVA 객체지향 핵심 원리"
author: "Lin"
tags: JAVA
---

모듈화된 소프트웨어 개발에 대한 요구 -> `객체지향 패러다임`
- 절차지향 언어: 실행되는 순서가 위에서부터 아래로 순차적으로 진행
    - 프로그램 재사용 시 기존에 만들어진 코드 복붙하는 방법 사용 <br>
    -> 해결법: 함수 사용 (자주 사용되는 특정 코드를 하나의 모듈로 묶어 놓은 것) <br>
    -> 한계점: 데이터와 함수 간의 유기적인 관계성을 갖지 못함 
- 객체지향 언어: 모듈화를 위해 자신이 가진 고유의 **데이터**와 그 데이터를 처리할 수 있는 **메소드**를 가진 **객체** 등장 <br>
-> 객체들이 모여 객체지향 프로그램 구조 형성 <br>
-> 보다 높은 유지보수성 및 객체 간 자유로운 이동 

<br>

## 객체지향 언어
- 객체(Object): 현실 세계에 존재하는 유무형의 모든 것
    - 정적인 요소: 변수, 동적인 요소: 메서드 
- 클래스: 현실 세계의 객체를 컴퓨터 메모리에 생성할 수 있는 템플릿 및 자바를 구성하는 가장 기본적 요소
- 인스턴스: 클래스로부터 생성된 **메모리에 존재**하는 객체 

<br>

## 장단점
### 장점
1. 코드의 재사용성 
    - 남이 만든 코드 사용 가능, 상속을 통해 확장 가능
2. 쉬운 유지보수
    - 수정할 부분이 클래스 내부 또는 메소드로 존재하기 때문에 해당 부분만 수정 가능
3. 대형 프로젝트에 적합
    - 클래스 단위로 모듈화 가능 -> 업무 분담

### 단점
1. 상대적으로 느린 처리 속도
2. 객체가 많으면 용량 증가
3. 설계 시 많은 노력과 시간 필요 

<br>

## 특징 
### 상속
기존의 클래스를 이용해서 새로운 클래스를 작성
- 클래스들 사이에 공통된 속성이나 기능들이 있을 경우, 상속을 통해 기능의 확장 가능 
- 객체들 사이의 계층 구조 형성 (상위 계층: 일반화, 보편화 -> 하위 계층: 특수화, 개별화)
- 부모 클래스와 자식 클래스의 관계가 논리적으로 `일반화, 특별화 관계(is a~)`이어야 함 
- 다중 상속: 일반적으로 하나의 하위 클래스가 하나의 상위 클래스를 갖는 단일 상속이지만 하나의 클래스가 두 개 이상의 상위 클래스를 갖도록 계층구조를 생성 가능 <br<
-> 그러나, 자바는 `단일 상속`만을 지원 

<br>

### 다형성 
- `One interface, Multiple implementation`
    - 하나의 인터페이스를 통해 서로 다른 구현을 제공
- 메서드 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 지원
    - 오버로딩: 한 클래스 안에 같은 이름의 메서드를 여러 개 정의하면서 인자의 개수나 유형을 다르게 해놓은 형태 
    - 오버라이딩: 상속 관게에 있는 하위 클래스가 상위 클래스가 가지고 있는 메서드를 재정의하는 것 <br>
    재정의된 메서드가 선언된 형태는 상위 클래스와 같음 

<br>
   
### 추상화 
다양한 객체들의 `공통된 특성을 모아 일반화`하는 것 -> `클래스 정의`에 중요한 역할

<br>

### 캡슐화
- 변수와 메서드를 하나의 `추상화된 클래스로 묶는 과정` <br>
-> 변수와 메서드를 **독립적으로 동작하지 않도록 함**
- 객체가 제공하는 메서드를 통해 객체를 이용해 실제로 데이터가 어떻게 처리되는지 알 필요 없음
<br>
```
정보 은닉: 캡슐화된 변수나 메서드를 선택적으로 공개하거나 숨길 수 있음
```

<br>

### 메시지
- 객체 간의 서로 통신하는 방법
- 객체 간에 메시지를 주고받기 때문에 여러 객체는 동일한 프로세스를 가질 필요 없음 
- 메시지를 주고받는 데 객체가 존재하는 위치는 제약이 되지 않음 

<br>

## 객체 지향 설계 원칙
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
    - 클래스는 단 하나의 책임을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
2. OCP(Open Closed Principle) : 개방 폐쇄 원칙
    - 확장에는 열려있고, 변경에는 닫혀있어야 한다.
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.    
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
