---
layout: post
title: "클린 아키텍처 in 안드로이드"
author: "Lin"
tags: Android
---

# 클린 아키텍처 

> **“빠르고 신속하게 코드작성을 하고 싶다면, 코드를 읽기 쉽게 만들어라”** *– Robert C. Martin*

<br>

좋은 아키텍처는 유즈케이스를 중심에 두기 때문에, 모든 유즈케이스에 대해 유닛 테스트를 할 수 있으면 좋은 아키텍처라고 불린다. 

핵심적인 내용은 `관심사의 분리(Separation of concerns)` 이다.

아키텍처가 추구하는 내용은 다음과 같은 특징을 갖는다.

- UI, 데이터베이스, 프레임워크 등의 독립성 (결합도 down)
- 기능 변경 및 확장의 용이성 (유지보수의 용이성)
- 테스트 용이성 

<br>

클린 아키텍처는 Robert C Martin이 고안하였다. 위의 내용을 종합적으로 포함하면서 계층별로 관심사를 분리하고 비즈니스 로직을 캡슐화하는 소프트웨어 설계 철학이다. 

<br> 

## 클린 아키텍처 다이어그램 

![img](https://www.charlezz.com/wordpress/wp-content/uploads/2021/09/www.charlezz.com-mvvm-the-clean-architecture.png)

- `엔티티` : 전사적인 핵심 업무 규칙을 캡슐화 한다. 모든 플랫폼 애플리케이션에서 재사용 가능해야 한다. 외부의 무언가가 변경되어도 엔티티가 변경될 가능성은 낮다.
- `유스케이스` :  애플리케이션에 특화된 업무 규칙을 포함한다. 유스케이스는 엔티티로 들어오고 나가는 데이터의 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 한다. 변경사항이 엔티티에 영향을 줘서는 안 되며, UI 또는 프레임워크 등과 같은 외부 요소에서 발생한 변경이 이 게층에 영향을 줘서도 안 된다.
- `인터페이스 어댑터` : 인터페이스 어댑터 계층은 일련의 어댑터들로 구성된다. 어댑터가 하는 역할은 상대적으로 상위 계층인 유스케이스 그리고 프레임워크와 같은 하위 계층간의 중간다리 역할을 하며 서로가 가장 편리한 형식으로 변환한다. MVP, MVVM 같은 아키텍처가 여기 속한다.
- `프레임워크` : 안드로이드 프레임워크를 의미한다. 구글이 새로운 안드로이드 프레임워크를 배포할 때 변경사항이 발생하므로 우리는 안드리옫 프레임워크를 가장 외부에 위치시켜 피해를 최소화해야 한다.

<br>

### 계층 간 의존성 규칙 

각각의 동심원은 서로 다른 영역을 표현하고 있다. 바깥원은 메커니즘이고 안쪽원은 정책이다. 바깥원에서 안쪽원으로 의존하는 규칙을 갖는다. 즉, 안쪽원은 바깥쪽원에 대한 정보를 몰라야 한다. 외부원에 위치한 어느 것도 내부의 원에 영향을 주지 않기를 원한다.

안드로이드 프로젝트에서는 이러한 원칙을 지키기 위해 계층별로 `모듈을 분리`하고 의존 관계를 설정할 수 있다.

일반적으로 다음과 같이 나눌 수 있다.

- domain
- data
- presentation

<p align="center"><img src="https://www.charlezz.com/wordpress/wp-content/uploads/2021/09/www.charlezz.com-cleanarchitecture-circle.png" width="500" align="center"/></p>

![img](https://www.charlezz.com/wordpress/wp-content/uploads/2021/09/www.charlezz.com-mvvm-clean-architecture-diagram.png)

안드로이드 프로젝트에서 엔티티를 다른 플랫폼과 사실상 공유하기 힘들다. 그러므로 domain 모듈 아래에 유스케이스와 엔티티를 통합하였다. 

클린아키텍처의 동심원이 꼭 4개일 필요도 없다. 그저 개념을 설명하기 위한 예시일 뿐이다. 상황에 따라 더 많은 계층을 만들고 세분화할 수 있다. 다만 계층간 의존성 규칙은 반드시 지켜야 한다. 동심원 안쪽으로 이동할수록 추상화가 높아진다.

<br>

### domain 모듈

프로젝트 전체에 비즈니스 로직이 있으면 다음과 같은 일이 벌어진다.

- 기능 추가 또는 수정해야 하는 코드를 찾기 힘들다.
- 앱이 확장됨에 따라 코드들이 점점 더 복잡해진다.
- 기존 코드를 확장 및 재사용하기 어렵다.

<br>

domain 모듈은 앱의 중심부로 이 계층에 포함된 비즈니스 로직은 앱을 구성하고 있는 것 중 가장 중요한 부분이다. 그래서 이 게층은 어떠한 게층에도 의존하지 않는다. domain 모듈은 다음과 같은 코드를 포함한다.

- Entity: 특정 영역을 포함하는 객체 ex) Pojo, VO, DTO 등
- UseCase: Entity와 함께 비즈니스 로직을 수행
- Repository 인터페이스: 데이터베이스, 원격 서버와 같은 데이터 소스에 접근 

domain 모듈은 비즈니스 로직을 한 계층에서 관리하는데 초점을 맞춘다. 이를 통해 코드를 깨끗하게 관리하고, 단일 책임 원칙(SRP: Single Responsibility Principle)에 부한하는 코드를 작성하기 쉬워진다. 

<br>

### data 모듈 

data 모듈은 데이터 소스(DB, 서버 등)와 상호작용을 담당하는 코드가 포함되는 곳이다. data 모듈은 domain 모듈에 의존한다. 

앱은 여러 데이터 소스를 사용할 텐데, 시간이 지남에 따라 변경될 수 있다. 이러한 변경사항은 오로지 데이터를 처리하는데 관련된 로직일 뿐 데이터를 필요로 하는 코드에는 영향을 미치지 않는다.

<br>

data 모듈은 다음과 같은 두 가지 책임을 갖는다.

- 데이터 입출력 코드를 하나의 게층에서 관리한다.
- 데이터 소스들과 데이터를 소비하는 다른 계층과의 경계를 둔다.

data 모듈에서는 domain 모듈에서 정의한 Repository 인터페이스를 구현한다. 이게 구글에서 추천하는 Repository 패턴이다.

![img](https://www.charlezz.com/wordpress/wp-content/uploads/2021/09/www.charlezz.com-original.png)

domain과 data 간의 분리가 이뤄졌기 때문에, 데이터 소스를 변경해도 domain 모듈에는 영향이 없어 비즈니스 로직은 안전하다.

<br>

### presentation 모듈

domain, data 모듈에 의존한다. 프레젠테이션 게층은 UI와 관련된 코드를 캡슐화한다. 모든 UI와 관련된 컴포넌트 또는 안드로이드 프레임워크와 관련된 코드를 다루게 된다.

UI/UX는 비즈니스 로직에 비해 상대적으로 변경할 일이 많다. UI와 관련된 유닛테스트는 어렵기 때문에 UI와 관련된 내용은 다른 코드에 의존성이 없도록 최대한 독립적으로 만들어야 한다. UI 코드를 한 곳에서 관리함으로써 비즈니스 로직을 보호하고 테스트도 쉽게 만든다.

<br>

## 제어의 흐름 

첫 번째 그림에 `제어의 흐름(flow of control)`을 나타내고 있다. 안드로이드로 말하자면 시스템 이벤트 또는 사용자의 입력을 받아 유스케이스를 통과한 후 처리한 결과를 View에 렌더링하여 마무리한다. 

![img](https://www.charlezz.com/wordpress/wp-content/uploads/2021/09/www.charlezz.com-clean-architecture-diagram-flow.png)

유스케이스에서 프레젠터와 같은 하위 게층의 코드를 직접 참조하여 호출해버리면 클린 아키텍처의 게층 간 의존성 규칙을 위반하게 된다. 제어의 흐름과 동심원들의 의존성 방향이 반대가 되는 경우는 인터페이스와 함께 의존성 역전 원칙을 사용하여 해결한다. 클린 아키텍처에서 동심원 경계를 횡단할 때 언제라도 동일한 기법을 사용할 수 있다. 

<br>

계층을 횡단하면서 데이터를 전할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 한다.

예를 들어, 서버에 저장도니 사용자 정보를 갱신하기 위해 다음과 같이 가정해보자.

- 사용자 정보를 갱신하기 위해 API를 호출한다.
- domain에서 사용자 정보는 User라는 형태로 표현한다.
- presentation에서 View에 사용자 정보를 나타낼 때는 UserUiModel로 표현한다.
- data에서 서버로부터 응답받은 사용자 정보는 UserDTO로 표현한다.

사용자 정보 갱신 API 호출을 위해 Activity에서 유스케이스를 호출할 때 UserUiModel은 User로 변환되어야 한다. 또한, Retrofit을 통해 API 요청에 따른 응답 UserDTO를 받았고, 이를 다시 유스케이스로 넘기기 위해서는 User로 변경해야 한다. 흐름이 반대 방향일 때도 마찬가지로 변경이 필요하다.

`UserUiModel <-> User <-> UserDTO`

이렇게 경계를 횡단할 때 데이터의 모습이 변경될 수 있으며, 데이터 구조가 어떤 의존성으 가져서 의존성 규칙을 위배하게 되면 안 된다. 일반적으로 데이터의 형태를 변경할 때 접미어로 Mapper라고 하는 객체를 임의적으로 만들어 사용한다. 

<br>

<br>

[안드로이드에 클린 아키텍처를 도입한다면 어떻게 될까?](https://www.charlezz.com/?p=45391)
